/*
 * Order Lunch Ginno
 *
 * This is a order lunch server for everyone worked at Ginnovation. APIs are writed by swagger [http://swagger.io](http://swagger.io) or on  [irc.freenode.net, #swagger](http://swagger.io/irc/).
 *
 * API version: 1.0.0
 * Contact: apiteam@ginno.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"database/sql"
	"time"
)

// Order from user
type Order struct {
	ID int `json:"id"`

	UserID int64 `json:"userId"`

	DishID int64 `json:"dishId"`

	OrderDate time.Time `json:"orderDate"`

	Quantity int64 `json:"quantity"`

	// Order Status
	Status string `json:"status"`
}

func (o *Order) addOrder(db *sql.DB) error {
	err := db.QueryRow(
		"INSERT INTO orders(UserID, DishID, OrderDate, Quantity, Status) VALUES($1, $2, $3, $4, $5) RETURNING id",
		o.UserID, o.DishID, o.OrderDate, o.Quantity, o.Status).Scan(&o.ID)
	if err != nil {
		return err
	}

	return nil
}

func (o *Order) deleteOrder(db *sql.DB) error {
	_, err := db.Exec("DELETE FROM orders WHERE id=$1", o.ID)
	return err
}

func (o *Order) getOrderByID(db *sql.DB) error {
	err := db.QueryRow("SELECT * FROM orders WHERE id=$1",
		o.ID).Scan(&o.ID, &o.UserID, &o.DishID, &o.OrderDate, &o.Quantity, &o.Status)
	return err
}

func (o *Order) updateOrder(db *sql.DB) error {
	_, err := db.Exec("UPDATE orders SET UserID=$1 DishID=$2 OrderDate=$3 Quantity=$4 Status=$5 WHERE id=$6",
		o.UserID, o.DishID, o.OrderDate, o.Quantity, o.Status, o.ID)
	return err
}

func getListOrder(db *sql.DB, OrderDate time.Time) ([]Order, error) {
	rows, err := db.Query("SELECT * FROM orders WHERE OrderDate=$1", OrderDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	orders := []Order{}
	for rows.Next() {
		var o Order
		if err := rows.Scan(&o.ID, &o.UserID, &o.DishID, &o.OrderDate, &o.Quantity, &o.Status); err != nil {
			return nil, err
		}
		orders = append(orders, o)
	}

	return orders, nil
}

func getTotalOrder(db *sql.DB, OrderDate time.Time) (int, error) {
	row, err := db.Query("SELECT COUNT(*) FROM orders WHERE OrderDate=$1", OrderDate)
	if err != nil {
		return 0, err
	}
	defer row.Close()

	total := 0
	row.Next()
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, err
}
